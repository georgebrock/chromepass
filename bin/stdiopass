#!/usr/bin/env python

import json
import re
import struct
import subprocess
import sys


class ChromeNativeMessaging(object):
    """
    Reads and writes the Google Chrome native messaging protocol, which
    sends and recieves UTF-8 encoded JSON prefixed with a 4 byte length
    indicator.
    """

    class ConnectionClosed(Exception):
        pass

    def read(self):
        """
        Reads a message from Google Chrome, and returns it.
        Can raise a ChromeNativeMessaging.ConnectionClosed exception.
        """

        length_bytes = sys.stdin.read(4)

        if len(length_bytes) == 0:
            raise self.ConnectionClosed()

        length = struct.unpack('i', length_bytes)[0]
        message = sys.stdin.read(length).decode('utf-8')
        return json.loads(message)

    def write(self, payload):
        """
        Serializes the given payload as JSON, and sends it to Google Chrome.
        """

        message = json.dumps(payload)
        sys.stdout.write(struct.pack('I', len(message)))
        sys.stdout.write(message)
        sys.stdout.flush()


class Password(object):
    """
    Represents an entry in the password store. The entry will be lazily
    decrypted when the ``password`` or ``extra_info`` properties are
    accessed.
    """

    @classmethod
    def for_domain(cls, domain):
        return cls('www/{0}'.format(domain))

    def __init__(self, name):
        self.name = name

    @property
    def password(self):
        """
        Returns the password, assumed to be the first line of the password
        file.
        """

        return self.decrypted_lines[0]

    @property
    def extra_info(self):
        """
        Returns a dict of extra information in the password file, assumed to
        consist of colon separated key/value pairs on every line but the first.

        e.g. the line ``'foo: bar'`` would result in the
        dict ``{'foo': 'bar'}``
        """

        separator = re.compile(r':\s+')
        return dict([
            separator.split(line, maxsplit=2)
            for line in self.decrypted_lines[1:]
            if len(line) > 0
        ])

    @property
    def decrypted_lines(self):
        if not hasattr(self, '_decrypted_lines'):
            output = subprocess.check_output(['pass', self.name])
            self._decrypted_lines = output.splitlines()

        return self._decrypted_lines


class MessageHandler(object):
    """
    Converts messages from the browser into responses to send back to the
    browser.
    """

    def handle(self, message):
        domain = message['domain']
        password = Password.for_domain(domain)
        return {
            'name': password.name,
            'password': password.password,
            'extra': password.extra_info,
        }


if __name__ == '__main__':
    chrome = ChromeNativeMessaging()
    message_handler = MessageHandler()

    while True:
        try:
            message = chrome.read()
        except ChromeNativeMessaging.ConnectionClosed:
            sys.exit(0)

        response = message_handler.handle(message)
        chrome.write(response)
